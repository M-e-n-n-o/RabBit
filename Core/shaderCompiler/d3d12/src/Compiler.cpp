#include "Compiler.h"
#include "Utils.h"

#include <filesystem>
#include <sstream>
#include <regex>

Compiler::Compiler()
{
	HRESULT hr;
	hr = DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&m_Utils));
	EXIT_ON_FAIL_HR(hr, L"Failed to create utils instance");
	hr = DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&m_Compiler));
	EXIT_ON_FAIL_HR(hr, L"Failed to create compiler instance");

	// Create default include handler (Create our own when necessary!)
	m_Utils->CreateDefaultIncludeHandler(&m_IncludeHandler);
}

void Compiler::CompileFiles(std::vector<std::wstring>& files)
{
	for (const std::wstring& file : files)
	{
		HRESULT status;

		// Open source file
		CComPtr<IDxcBlobEncoding> source_blob = nullptr;
		status = m_Utils->LoadFile(file.c_str(), nullptr, &source_blob);
		EXIT_ON_FAIL_HR(status, L"Failed to load file: " << file.c_str());

		LOGW(L"Got \"" << file.c_str() << "\"");

		DxcBuffer source;
		source.Ptr		= source_blob->GetBufferPointer();
		source.Size		= source_blob->GetBufferSize();
		source.Encoding = DXC_CP_ACP;

		std::vector<Shader> entries;
		RetrieveShaderEntries(source, entries);

		if (entries.empty())
		{
			continue;
		}

		for (Shader& entry : entries)
		{
			LOGW(L"Compiling: " << entry.entryName.c_str());

			wchar_t* target;
			switch (entry.stage)
			{
			case ShaderStage::kVertex:	target = L"vs_6_6"; break;
			case ShaderStage::kPixel:	target = L"ps_6_6"; break;
			case ShaderStage::kCompute:	target = L"cs_6_6"; break;
			default:
				EXIT_ON_FAIL(false, "Could not detect the shader stage type in shader: " << file.c_str());
				break;
			}

			std::wstring bin_name(entry.entryName);
			bin_name.append(L".bin");
			std::wstring pdb_name(entry.entryName);
			pdb_name.append(L".pdb");

			LPCWSTR psz_args[] =
			{
				file.c_str(),					// Optional shader source file name for error reporting
												// and for PIX shader source view.  
				L"-E", entry.entryName.c_str(),	// Entry point.
				L"-T", target,					// Target.
				L"-Zs",							// Enable debug information (slim format)
				L"-D", L"SHADER=1",				// A single define.
				L"-Fo", bin_name.c_str(),		// Optional. Stored in the pdb. 
				L"-Fd", pdb_name.c_str(),		// The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
				L"-Qstrip_reflect",				// Strip reflection into a separate blob. 
			};

			// Compile with specified arguments
			CComPtr<IDxcResult> results;
			m_Compiler->Compile(
				&source,					// Source buffer.
				psz_args,					// Array of pointers to arguments.
				_countof(psz_args),			// Number of arguments.
				m_IncludeHandler,			// User-provided interface to handle #include directives (optional).
				IID_PPV_ARGS(&results)		// Compiler output status, buffer, and errors.
			);

			// Print errors if present
			CComPtr<IDxcBlobUtf8> errors = nullptr;
			results->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&errors), nullptr);

			if (errors != nullptr && errors->GetStringLength() != 0)
			{
				LOG(errors->GetStringPointer());
			}

			// Exit on fail
			results->GetStatus(&status);
			EXIT_ON_FAIL_HR(status, L"Compilation failed");

			results->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&entry.shaderBlob), nullptr);
			EXIT_ON_FAIL(entry.shaderBlob != nullptr, "Could not retrieve shader binary");

			results->GetOutput(DXC_OUT_REFLECTION, IID_PPV_ARGS(&entry.reflection), nullptr);
			EXIT_ON_FAIL(entry.reflection != nullptr, "Could not retrieve shader reflection");

			AddInputMasks(entry);

			m_CompiledShaders.push_back(entry);
		}

	}
}

void Compiler::RetrieveShaderEntries(DxcBuffer& source, std::vector<Shader>& entries)
{
	GetShaderStages((char*)source.Ptr, ShaderStage::kVertex,  "VS_",  entries);
	GetShaderStages((char*)source.Ptr, ShaderStage::kPixel,   "PS_",   entries);
	GetShaderStages((char*)source.Ptr, ShaderStage::kCompute, "CS_", entries);
}

void Compiler::GetShaderStages(const char* source, ShaderStage stage, const char* prefix, std::vector<Shader>& entries)
{
	std::size_t pos;
	std::string string_source(source);
	
	while (true)
	{
		pos = string_source.find(prefix);
		if (pos == std::string::npos)
		{
			break;
		}

		// Get to the point where we found the prefix
		string_source = string_source.substr(pos, string_source.length());

		// Find the end of the name
		pos = string_source.find('(');
		EXIT_ON_FAIL(pos != std::string::npos, "Could not find the end of the name");

		Shader entry;
		entry.stage		= stage;
		entry.entryName = ConvertAnsiToWide(string_source.substr(0, pos));

		entries.push_back(entry);

		// Get past the shader we just found
		string_source = string_source.substr(pos, string_source.length());
	}
}

void Compiler::AddInputMasks(Shader& shader)
{
	DxcBuffer reflection_data;
	reflection_data.Encoding = DXC_CP_ACP;
	reflection_data.Size	 = shader.reflection->GetBufferSize();
	reflection_data.Ptr		 = shader.reflection->GetBufferPointer();

	CComPtr<ID3D12ShaderReflection> reflection;
	EXIT_ON_FAIL_HR(m_Utils->CreateReflection(&reflection_data, IID_PPV_ARGS(&reflection)), L"Failed to load reflection data");

	D3D12_SHADER_DESC desc;
	EXIT_ON_FAIL_HR(reflection->GetDesc(&desc), L"Failed to get description of shader: " << shader.entryName);

	shader.cbvMask = 0;
	shader.srvMask = 0;
	shader.uavMask = 0;
	shader.samplerMask = 0;

	for (int i = 0; i < desc.BoundResources; ++i)
	{
		D3D12_SHADER_INPUT_BIND_DESC input_desc;
		EXIT_ON_FAIL_HR(reflection->GetResourceBindingDesc(i, &input_desc), L"Failed to get resource " << std::to_wstring(i));

		switch (input_desc.Type)
		{
			case D3D_SIT_CBUFFER:
			{
				//LOGW("CBV at: " << input_desc.BindPoint);
				shader.cbvMask |= (1 << input_desc.BindPoint);
			}
			break;
			case D3D_SIT_SAMPLER:
			{
				//LOGW("Sampler at: " << input_desc.BindPoint);
				shader.samplerMask |= (1 << input_desc.BindPoint);
			}
			break;
			case D3D_SIT_TBUFFER:
			case D3D_SIT_TEXTURE:
			case D3D_SIT_STRUCTURED:
			case D3D_SIT_BYTEADDRESS:
			case D3D_SIT_RTACCELERATIONSTRUCTURE:
			{
				//LOGW("SRV at: " << input_desc.BindPoint);
				shader.srvMask |= (1 << input_desc.BindPoint);
			}
			break;
			case D3D_SIT_UAV_RWTYPED:
			case D3D_SIT_UAV_RWSTRUCTURED:
			case D3D_SIT_UAV_RWBYTEADDRESS:
			case D3D_SIT_UAV_APPEND_STRUCTURED:
			case D3D_SIT_UAV_CONSUME_STRUCTURED:
			case D3D_SIT_UAV_RWSTRUCTURED_WITH_COUNTER:
			case D3D_SIT_UAV_FEEDBACKTEXTURE:
			{
				//LOGW("UAV at: " << input_desc.BindPoint);
				shader.uavMask |= (1 << input_desc.BindPoint);
			}
			break;
		default:
			LOGW("Bounded input resource " << std::to_wstring(i) << " is not valid");
			break;
		}
	}
}
