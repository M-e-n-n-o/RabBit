#include "Compiler.h"
#include "Utils.h"

#include <filesystem>
#include <sstream>
#include <regex>

Compiler::Compiler()
{
	HRESULT hr;
	hr = DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&m_Utils));
	EXIT_ON_FAIL_HR(hr, L"Failed to create utils instance");
	hr = DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&m_Compiler));
	EXIT_ON_FAIL_HR(hr, L"Failed to create compiler instance");

	// Create default include handler (TODO Create our own)
	m_Utils->CreateDefaultIncludeHandler(&m_IncludeHandler);
}

void Compiler::CompileFiles(std::vector<std::wstring>& files)
{
	for (const std::wstring& file : files)
	{
		HRESULT status;

		// Open source file
		CComPtr<IDxcBlobEncoding> source_blob = nullptr;
		status = m_Utils->LoadFile(file.c_str(), nullptr, &source_blob);
		EXIT_ON_FAIL_HR(status, L"Failed to load file: " << file.c_str());

		LOG(L"Got \"" << file.c_str() << "\"");

		DxcBuffer source;
		source.Ptr		= source_blob->GetBufferPointer();
		source.Size		= source_blob->GetBufferSize();
		source.Encoding = DXC_CP_ACP;

		std::vector<ShaderEntry> entries;
		RetrieveShaderEntries(source, entries);

		if (entries.empty())
		{
			continue;
		}

		for (const ShaderEntry& entry : entries)
		{
			LOG(L"Compiling: " << entry.entryName.c_str());

			wchar_t* target;
			switch (entry.stage)
			{
			case ShaderStage::kVertex:	target = L"vs_6_0"; break;
			case ShaderStage::kPixel:	target = L"ps_6_0"; break;
			case ShaderStage::kCompute:	target = L"cs_6_0"; break;
			default:
				EXIT_ON_FAIL(false, "Could not detect the shader stage type in shader: " << file.c_str());
				break;
			}

			std::wstring bin_name(entry.entryName);
			bin_name.append(L".bin");
			std::wstring pdb_name(entry.entryName);
			pdb_name.append(L".pdb");

			LPCWSTR psz_args[] =
			{
				file.c_str(),					// Optional shader source file name for error reporting
												// and for PIX shader source view.  
				L"-E", entry.entryName.c_str(),	// Entry point.
				L"-T", target,					// Target.
				L"-Zs",							// Enable debug information (slim format)
				L"-D", L"SHADER=1",				// A single define.
				L"-Fo", bin_name.c_str(),		// Optional. Stored in the pdb. 
				L"-Fd", pdb_name.c_str(),		// The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
				L"-Qstrip_reflect",				// Strip reflection into a separate blob. 
			};

			// Compile with specified arguments
			CComPtr<IDxcResult> results;
			m_Compiler->Compile(
				&source,					// Source buffer.
				psz_args,					// Array of pointers to arguments.
				_countof(psz_args),			// Number of arguments.
				m_IncludeHandler,			// User-provided interface to handle #include directives (optional).
				IID_PPV_ARGS(&results)		// Compiler output status, buffer, and errors.
			);

			// Print errors if present
			CComPtr<IDxcBlobUtf8> errors = nullptr;
			results->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&errors), nullptr);

			if (errors != nullptr && errors->GetStringLength() != 0)
			{
				LOG(errors->GetStringPointer());
			}

			// Exit on fail
			results->GetStatus(&status);
			EXIT_ON_FAIL_HR(status, L"Compilation failed");





			// Write out .bin file
			CComPtr<IDxcBlob> shader = nullptr;
			CComPtr<IDxcBlobUtf16> shader_name = nullptr;
			results->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&shader), &shader_name);
			if (shader != nullptr)
			{
				std::wstring output_file;
				output_file.append(ConvertAnsiToWide(RB_SHADER_SOURCE));
				output_file.append(L"/generated/");
				output_file.append(shader_name->GetStringPointer());

				FILE* fp = NULL;
				_wfopen_s(&fp, output_file.c_str(), L"wb");
				fwrite(shader->GetBufferPointer(), shader->GetBufferSize(), 1, fp);
				fclose(fp);
			}

			/*
				TODO:
				- Write all blobs of the same shader stage to a single .h file (so VertexShaderBlobs.h, PixelShaderBlobs.h, etc.).
				  In this file a variable containing the shader blob is made for each shader itself. This .h file can the shader reader in the engine then simply include.
				  A second file for each shader stage is also made that contains a typename shader index for each shader (so VertexShader.h, PixelShader.h). The engine can then include this file to point which shader to use.
				- Include handlnig to include other hlsl and .h files
				- Shader reflection to automatically create PSO's

				https://github.com/microsoft/DirectXShaderCompiler/wiki/Using-dxc.exe-and-dxcompiler.dll
			*/
		}

	}
}

void Compiler::RetrieveShaderEntries(DxcBuffer& source, std::vector<ShaderEntry>& entries)
{
	GetShaderStages((char*)source.Ptr, ShaderStage::kVertex,  "#vertex_shader",  entries);
	GetShaderStages((char*)source.Ptr, ShaderStage::kPixel,   "#pixel_shader",   entries);
	GetShaderStages((char*)source.Ptr, ShaderStage::kCompute, "#compute_shader", entries);
}

void Compiler::GetShaderStages(const char* source, ShaderStage stage, const char* stage_name, std::vector<ShaderEntry>& entries)
{
	std::size_t pos;
	std::string string_source(source);
	
	while (true)
	{
		pos = string_source.find(stage_name);
		if (pos == std::string::npos)
		{
			break;
		}

		// Get past the string we were searching for
		string_source = string_source.substr(pos + strlen(stage_name), string_source.length());

		// Remove leading spaces
		string_source = std::regex_replace(string_source, std::regex("^ +"), "");

		// Find the end of the name
		pos = string_source.find('\n');
		EXIT_ON_FAIL(pos != std::string::npos, "Could not find the end of the name");

		ShaderEntry entry;
		entry.stage		= stage;
		entry.entryName = ConvertAnsiToWide(string_source.substr(0, pos - 1));

		entries.push_back(entry);
	}
}
